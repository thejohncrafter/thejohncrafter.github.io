(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "../rustlib/pkg/tipe.js":
/*!******************************!*\
  !*** ../rustlib/pkg/tipe.js ***!
  \******************************/
/*! exports provided: IFaceResult, WasmInterface, __wbindgen_throw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IFaceResult\", function() { return IFaceResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WasmInterface\", function() { return WasmInterface; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_throw\", function() { return __wbindgen_throw; });\n/* harmony import */ var _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tipe_bg.wasm */ \"../rustlib/pkg/tipe_bg.wasm\");\n\n\nlet cachegetInt32Memory = null;\nfunction getInt32Memory() {\n    if (cachegetInt32Memory === null || cachegetInt32Memory.buffer !== _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetInt32Memory = new Int32Array(_tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetInt32Memory;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory = null;\nfunction getUint8Memory() {\n    if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetUint8Memory = new Uint8Array(_tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetUint8Memory;\n}\n\nfunction getStringFromWasm(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory().subarray(ptr, ptr + len));\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm(arg) {\n\n    let len = arg.length;\n    let ptr = _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"](len);\n\n    const mem = getUint8Memory();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"](ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n/**\n*/\nclass IFaceResult {\n\n    static __wrap(ptr) {\n        const obj = Object.create(IFaceResult.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_ifaceresult_free\"](ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_ok() {\n        const ret = _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"ifaceresult_is_ok\"](this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {string}\n    */\n    get_decl() {\n        const retptr = 8;\n        const ret = _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"ifaceresult_get_decl\"](retptr, this.ptr);\n        const memi32 = getInt32Memory();\n        const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();\n        _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);\n        return v0;\n    }\n}\n/**\n*/\nclass WasmInterface {\n\n    static __wrap(ptr) {\n        const obj = Object.create(WasmInterface.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_wasminterface_free\"](ptr);\n    }\n    /**\n    * @returns {WasmInterface}\n    */\n    static new() {\n        const ret = _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"wasminterface_new\"]();\n        return WasmInterface.__wrap(ret);\n    }\n    /**\n    * @param {string} axioms_def\n    * @returns {IFaceResult}\n    */\n    register_axioms(axioms_def) {\n        const ret = _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"wasminterface_register_axioms\"](this.ptr, passStringToWasm(axioms_def), WASM_VECTOR_LEN);\n        return IFaceResult.__wrap(ret);\n    }\n    /**\n    * @param {string} decl\n    * @returns {IFaceResult}\n    */\n    exec_proof(decl) {\n        const ret = _tipe_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"wasminterface_exec_proof\"](this.ptr, passStringToWasm(decl), WASM_VECTOR_LEN);\n        return IFaceResult.__wrap(ret);\n    }\n}\n\nconst __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm(arg0, arg1));\n};\n\n\n//# sourceURL=webpack:///../rustlib/pkg/tipe.js?");

/***/ }),

/***/ "../rustlib/pkg/tipe_bg.wasm":
/*!***********************************!*\
  !*** ../rustlib/pkg/tipe_bg.wasm ***!
  \***********************************/
/*! exports provided: memory, __wbg_wasminterface_free, __wbg_ifaceresult_free, ifaceresult_is_ok, ifaceresult_get_decl, wasminterface_new, wasminterface_register_axioms, wasminterface_exec_proof, __wbindgen_malloc, __wbindgen_realloc, __wbindgen_free */
/***/ (function(module, exports, __webpack_require__) {

eval("\"use strict\";\n// Instantiate WebAssembly module\nvar wasmExports = __webpack_require__.w[module.i];\n__webpack_require__.r(exports);\n// export exports from WebAssembly module\nfor(var name in wasmExports) if(name != \"__webpack_init__\") exports[name] = wasmExports[name];\n// exec imports from WebAssembly module (for esm order)\n/* harmony import */ var m0 = __webpack_require__(/*! ./tipe.js */ \"../rustlib/pkg/tipe.js\");\n\n\n// exec wasm module\nwasmExports[\"__webpack_init__\"]()\n\n//# sourceURL=webpack:///../rustlib/pkg/tipe_bg.wasm?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var rustlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rustlib */ \"../rustlib/pkg/tipe.js\");\n/* harmony import */ var xterm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xterm */ \"./node_modules/xterm/lib/xterm.js\");\n/* harmony import */ var xterm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(xterm__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var xterm_addon_fit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! xterm-addon-fit */ \"./node_modules/xterm-addon-fit/lib/xterm-addon-fit.js\");\n/* harmony import */ var xterm_addon_fit__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(xterm_addon_fit__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n\nconst axioms = `\n(axiom_ext (forall x (forall y (then\n        (forall z (iff (in (var z) (var x)) (in (var z) (var y))))\n        (eq (var x) (var y))\n))))\n\n(axiom_empty (exists a (and\n    (exists C (in (var a) (var C)))\n    (forall x (not (in (var x) (var a))))\n)))\n\n(axiom_pair (forall x (forall y (then\n    (and (exists C (in (var x) (var C))) (exists C (in (var y) (var C))))\n    (exists a (and\n        (exists C (in (var a) (var C)))\n        (forall z (iff\n            (in (var z) (var a))\n            (or (eq (var z) (var x)) (eq (var z) (var y)))\n        ))\n    ))\n))))\n`\n\nconst proof = `\n\n# Un commentaire\n\n(prop A) (prop B) (prop C)\n(hyp H0 (and (then (var A) (var B)) (then (var B) (var C))))\n  (hyp A (var A))\n    (reg A_then_B (elim_and_l (get H0)))\n    (reg B_then_C (elim_and_r (get H0)))\n    (reg A (get A))\n    (reg B (elim_then (get A_then_B) (get A)))\n    (reg C (elim_then (get B_then_C) (get B)))\n  (then ccl C)\n(then ccl ccl)\n(so_forall ccl C ccl) (so_forall ccl B ccl) (so_forall chained_ponens A ccl)\n\n(scope)\n  (prop A)\n    (prop B)\n      (hyp H0 (and (var A) (var B)))\n        (reg ccl (intro_and (elim_and_r (get H0)) (elim_and_l (get H0))))\n      (then ccl ccl)\n    (so_forall ccl B ccl)\n  (so_forall forall_dir A ccl)\n  (prop A)\n    (prop B)\n      (reg dir (elim_so_forall (var B) (elim_so_forall (var A) (get forall_dir))))\n      (reg rec (elim_so_forall (var A) (elim_so_forall (var B) (get forall_dir))))\n      (reg commutator (intro_iff (get dir) (get rec)))\n    (so_forall commutator B commutator)\n  (so_forall and_commut A commutator)\n(conclude and_commut and_commut)\n\n(scope)\n  (term x) (term y)\n    (hyp H (and\n      (and (exists C (in (var x) (var C))) (forall z (not (in (var z) (var x)))))\n      (and (exists C (in (var y) (var C))) (forall z (not (in (var z) (var y)))))\n    ))\n      (term z)\n        (hyp z_in_x (in (var z) (var x)))\n          (reg not_z_in_x (elim_forall (var z) (elim_and_r (elim_and_l (get H)))))\n          (reg absurd (intro_bot (get z_in_x) (get not_z_in_x)))\n          (reg z_in_y (elim_bot (in (var z) (var y)) (get absurd)))\n        (then ccl z_in_y)\n      (forall ccl z ccl)\n    (then ccl ccl)\n  (forall ccl y ccl) (forall ccl x ccl)\n  (term x) (term y)\n    (hyp H (and\n      (and (exists C (in (var x) (var C))) (forall z (not (in (var z) (var x)))))\n      (and (exists C (in (var y) (var C))) (forall z (not (in (var z) (var y)))))\n    ))\n      (reg dir (elim_then (elim_forall (var y) (elim_forall (var x) (get ccl))) (get H)))\n      (reg comm\n        (elim_iff_r\n          (elim_so_forall\n            (and (exists C (in (var x) (var C))) (forall z (not (in (var z) (var x)))))\n            (elim_so_forall\n              (and (exists C (in (var y) (var C))) (forall z (not (in (var z) (var y)))))\n              (get and_commut)\n            )\n          )\n        )\n      )\n      (reg rec\n        (elim_then\n          (elim_forall (var x) (elim_forall (var y) (get ccl)))\n          (elim_then\n            (get comm)\n            (get H)\n          )\n        )\n      )\n      (term z)\n        (reg in_x_iff_in_y (intro_iff\n          (elim_forall (var z) (get dir))\n          (elim_forall (var z) (get rec))\n        ))\n      (forall in_x_iff_in_y z in_x_iff_in_y)\n      (reg ext (elim_forall (var y) (elim_forall (var x) (get axiom_ext))))\n      (reg x_eq_y (elim_then (get ext) (get in_x_iff_in_y)))\n    (then ccl x_eq_y)\n  (forall ccl y ccl) (forall unique y ccl)\n  (reg unique (intro_and (get axiom_empty) (get unique)))\n  (reg unique (intro_exists_unique\n    x\n    (and (exists C (in (var x) (var C))) (forall z (not (in (var z) (var x)))))\n    (get unique)\n  ))\n(conclude empty_unique unique)\n\n(scope)\n  (hyp H (top))\n    (reg ccl (get empty_unique))\n  (then unique_op_prop ccl)\n  (make_op ∅ 0 (get unique_op_prop))\n(conclude_op ∅ ∅)\n\n(scope)\n  (term x) (term y)\n    (hyp x_y_sets (and (exists C (in (var x) (var C))) (exists C (in (var y) (var C)))))\n      (term a) (term b)\n        (hyp a_b_pairs\n          (and\n            (and\n              (exists C (in (var a) (var C)))\n              (forall z (iff (in (var z) (var a)) (or (eq (var z) (var x)) (eq (var z) (var y)))))\n            )\n            (and\n              (exists C (in (var b) (var C)))\n              (forall z (iff (in (var z) (var b)) (or (eq (var z) (var x)) (eq (var z) (var y)))))\n            )\n          )\n        )\n        (reg a_is_pair (elim_and_r (elim_and_l (get a_b_pairs))))\n        (reg b_is_pair (elim_and_r (elim_and_r (get a_b_pairs))))\n        (term z)\n          (hyp z_in_a (in (var z) (var a)))\n          (reg test (elim_iff_l (elim_forall (var z) (get a_is_pair))))\n          (reg cases (elim_then\n            (elim_iff_l (elim_forall (var z) (get a_is_pair)))\n            (get z_in_a)\n          ))\n          (switch\n            (get cases)\n            z_is_x (eq (var z) (var x))\n            z_is_y (eq (var z) (var y))\n          )\n            (reg a (elim_iff_r (elim_forall (var z) (get b_is_pair))))\n            (reg b (intro_or_l (get z_is_x) (eq (var z) (var y))))\n            (reg c (elim_then (get a) (get b)))\n          (ccl_and_switch (get c))\n            (reg a (elim_iff_r (elim_forall (var z) (get b_is_pair))))\n            (reg b (intro_or_r (eq (var z) (var x)) (get z_is_y)))\n            (reg c (elim_then (get a) (get b)))\n          (ccl_and_elim z_in_b (get c))\n        (then in_a_then_in_b z_in_b)\n        (forall in_a_then_in_b z in_a_then_in_b)\n      (then ccl in_a_then_in_b)\n      (forall ccl b ccl) (forall forall_incl a ccl)\n      (term a) (term b)\n        (hyp a_b_pairs\n          (and\n            (and\n              (exists C (in (var a) (var C)))\n              (forall z (iff (in (var z) (var a)) (or (eq (var z) (var x)) (eq (var z) (var y)))))\n            )\n            (and\n              (exists C (in (var b) (var C)))\n              (forall z (iff (in (var z) (var b)) (or (eq (var z) (var x)) (eq (var z) (var y)))))\n            )\n          )\n        )\n          (reg a_incl_b\n            (elim_then\n              (elim_forall (var b) (elim_forall (var a) (get forall_incl)))\n              (get a_b_pairs)\n            )\n          )\n          (reg commutated\n            (elim_then\n              (elim_iff_l\n                (elim_so_forall\n                  (and\n                    (exists C (in (var b) (var C)))\n                    (forall z (iff\n                      (in (var z) (var b))\n                      (or (eq (var z) (var x)) (eq (var z) (var y)))\n                    ))\n                  )\n                  (elim_so_forall\n                    (and\n                      (exists C (in (var a) (var C)))\n                      (forall z (iff\n                        (in (var z) (var a))\n                        (or (eq (var z) (var x)) (eq (var z) (var y)))\n                      ))\n                    )\n                    (get and_commut)\n                  )\n                )\n              )\n              (get a_b_pairs)\n            )\n          )\n          (reg b_incl_a\n            (elim_then\n              (elim_forall (var a) (elim_forall (var b) (get forall_incl)))\n              (get commutated)\n            )\n          )\n          (term z)\n            (reg ccl (intro_iff\n              (elim_forall (var z) (get a_incl_b))\n              (elim_forall (var z) (get b_incl_a))\n            ))\n          (forall in_a_iff_in_b z ccl)\n          (reg a_eq_b (elim_then\n            (elim_forall (var b) (elim_forall (var a) (get axiom_ext)))\n            (get in_a_iff_in_b)\n          ))\n        (then ccl a_eq_b)\n      (forall ccl b ccl) (forall pair_unique a ccl)\n      (reg pair_unique\n        (intro_exists_unique\n            a\n            (and\n              (exists C (in (var a) (var C)))\n              (forall z (iff (in (var z) (var a)) (or (eq (var z) (var x)) (eq (var z) (var y)))))\n            )\n            (intro_and\n              (elim_then (elim_forall (var y) (elim_forall (var x) (get axiom_pair))) (get x_y_sets))\n              (get pair_unique)\n            )\n        )\n      )\n    (then ccl pair_unique)\n  (forall ccl y ccl) (forall pair_def x ccl)\n(conclude pair_unique pair_def)\n\n(scope)\n  (make_op pair 2 (get pair_unique))\n(conclude_op pair pair)\n\n(print_all)\n\n`\n\nconst iface = rustlib__WEBPACK_IMPORTED_MODULE_0__[\"WasmInterface\"].new();\niface.register_axioms(axioms)\n\nconst term = new xterm__WEBPACK_IMPORTED_MODULE_1__[\"Terminal\"]()\nconst addon = new xterm_addon_fit__WEBPACK_IMPORTED_MODULE_2__[\"FitAddon\"]()\nterm.loadAddon(addon)\nterm.open(document.getElementById(\"terminal\"))\naddon.fit()\n\nfunction runProgram(text) {\n  let res = iface.exec_proof(text).get_decl()\n  term.clear()\n  term.write(res.replace(/\\n/g, \"\\r\\n\"))\n}\n\n\n//let out = document.getElementById(\"console-out\")\n//out.textContent = res\n\nrunProgram(proof)\n\nconst editor = ace.edit(\"editor\")\neditor.insert(proof)\n//editor.setTheme(\"ace/theme/twilight\")\neditor.commands.addCommand({\n    name: 'myCommand',\n    bindKey: {win: 'Ctrl-Enter',  mac: 'Command-Enter'},\n    exec: function(editor) {\n      runProgram(editor.getValue())\n    },\n    readOnly: true\n});\n\n/*const buttonsContainer = document.getElementById(\"buttons-container\")\nconst button = document.createElement(\"button\")\nbutton.innerHTML = \"abcdef\"\nbuttonsContainer.appendChild(button)*/\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ })

}]);